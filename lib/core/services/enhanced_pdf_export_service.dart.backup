/*
 * Copyright (c) 2025 Karim Hussen Patatas Hassam dos Santos
 * 
 * This file is part of Bloquinho.
 * 
 * Licensed under CC BY-NC-SA 4.0
 * Commercial use prohibited without permission.
 */

import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:open_file/open_file.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:path/path.dart' as path;
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter/widgets.dart' as fw;
import 'package:flutter_math_fork/flutter_math.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

import 'package:flutter/material.dart';

import '../../../core/l10n/app_strings.dart';
import 'enhanced_markdown_parser.dart';
import '../../../features/bloquinho/widgets/windows_code_block_widget.dart';

class EnhancedPdfExportService {
  pw.Font? _notoSansFont;
  pw.Font? _notoSansBoldFont;
  pw.Font? _notoEmojiFont;

  /// Carregar fontes Unicode e emoji
  Future<void> _loadFonts() async {
    print('ğŸ”¤ [PDF] Iniciando carregamento de fontes...');
    try {
      if (_notoSansFont == null) {
        print('ğŸ”¤ [PDF] Carregando NotoSans-Regular.ttf...');
        try {
          _notoSansFont = pw.Font.ttf(
              await rootBundle.load('assets/fonts/NotoSans-Regular.ttf'));
          print('âœ… [PDF] NotoSans-Regular.ttf carregado com sucesso');
        } catch (e) {
          print('âš ï¸ [PDF] Erro ao carregar NotoSans-Regular.ttf: $e');
          print('ğŸ”¤ [PDF] Usando fonte padrÃ£o Helvetica como fallback');
          _notoSansFont = pw.Font.helvetica();
        }
      }
      if (_notoEmojiFont == null) {
        print('ğŸ”¤ [PDF] Carregando NotoColorEmoji.ttf...');
        try {
          _notoEmojiFont = pw.Font.ttf(
              await rootBundle.load('assets/fonts/NotoColorEmoji.ttf'));
          print('âœ… [PDF] NotoColorEmoji.ttf carregado com sucesso');
        } catch (e) {
          print('âš ï¸ [PDF] Erro ao carregar NotoColorEmoji.ttf: $e');
          print(
              'ğŸ”¤ [PDF] Emoji font nÃ£o disponÃ­vel, usando apenas fonte principal');
          _notoEmojiFont = null;
        }
      }
      print('âœ… [PDF] Todas as fontes carregadas com sucesso');
    } catch (e) {
      print('âŒ [PDF] Erro crÃ­tico ao carregar fontes: $e');
      print('ğŸ”¤PDF] Usando fontes padrÃ£o do sistema');
      _notoSansFont = pw.Font.helvetica();
      _notoEmojiFont = null;
    }
  }

  /// Obter fonte padrÃ£o com fallback para emoji
  pw.Font _getDefaultFont() {
    print(
        'ğŸ”¤ [PDF] Obtendo fonte padrÃ£o: ${_notoSansFont != null ? 'NotoSans' : 'Helvetica'}');
    return _notoSansFont ?? pw.Font.helvetica();
  }

  /// Obter fontes de fallback para emoji
  List<pw.Font> _getFontFallbacks() {
    final fallbacks = _notoEmojiFont != null ? [_notoEmojiFont!] : <pw.Font>[];
    print('ğŸ”¤ [PDF] Fontes de fallback: ${fallbacks.length} fontes');
    return fallbacks;
  }

  /// Exportar widget como imagem
  Future<String?> exportWidgetAsImage({
    required GlobalKey widgetKey,
    required String fileName,
  }) async {
    print('ğŸ–¼ï¸ [PDF] Iniciando exportaÃ§Ã£o de widget como imagem...');
    try {
      print('ğŸ–¼ï¸ [PDF] Obtendo RenderRepaintBoundary...');
      final RenderRepaintBoundary boundary =
          widgetKey.currentContext!.findRenderObject() as RenderRepaintBoundary;
      print('ğŸ–¼ï¸ [PDF] RenderRepaintBoundary obtido com sucesso');

      print('ğŸ–¼ï¸ [PDF] Convertendo para imagem...');
      final ui.Image image = await boundary.toImage(pixelRatio: 3.0);
      print('ğŸ–¼ï¸ [PDF] Imagem convertida com sucesso');

      print('ğŸ–¼ï¸ [PDF] Convertendo para bytes...');
      final ByteData? byteData =
          await image.toByteData(format: ui.ImageByteFormat.png);
      final Uint8List pngBytes = byteData!.buffer.asUint8List();
      print('ğŸ–¼ï¸ [PDF] Bytes obtidos: ${pngBytes.length} bytes');

      print('ğŸ–¼ï¸ [PDF] Obtendo diretÃ³rio de downloads...');
      final downloadsDir = await _getDownloadsDirectory();
      print('ğŸ–¼ï¸ [PDF] DiretÃ³rio: ${downloadsDir.path}');

      final sanitizedFileName = _sanitizeFileName(fileName);
      final filePath = path.join(downloadsDir.path, '$sanitizedFileName.png');
      print('ğŸ–¼ï¸ [PDF] Caminho do arquivo: $filePath');

      print('ğŸ–¼ï¸ [PDF] Salvando arquivo...');
      final file = File(filePath);
      await file.writeAsBytes(pngBytes);
      print('âœ… [PDF] Arquivo salvo com sucesso: $filePath');

      return filePath;
    } catch (e) {
      print('âŒ [PDF] Erro ao exportar widget como imagem: $e');
      return null;
    }
  }

  /// Exportar imagem como PDF
  Future<File> exportImageToPdf({
    required Uint8List imageBytes,
    required String title,
    required AppStrings strings,
  }) async {
    print('ğŸ“„ [PDF] Iniciando exportaÃ§Ã£o de imagem para PDF...');
    try {
      final pdf = pw.Document();
      print('ğŸ“„ [PDF] Documento PDF criado');

      final image = pw.MemoryImage(imageBytes);
      print('ğŸ“„ [PDF] Imagem carregada: ${imageBytes.length} bytes');

      pdf.addPage(
        pw.Page(
          build: (pw.Context context) {
            return pw.Center(
              child: pw.Image(image),
            );
          },
        ),
      );
      print('ğŸ“„ [PDF] PÃ¡gina adicionada ao PDF');

      print('ğŸ“„ [PDF] Obtendo diretÃ³rio temporÃ¡rio...');
      final output = await getTemporaryDirectory();
      final file = File("${output.path}/$title.pdf");
      print('ğŸ“„ [PDF] Caminho do arquivo: ${file.path}');

      print('ğŸ“„ [PDF] Salvando PDF...');
      await file.writeAsBytes(await pdf.save());
      print('âœ… [PDF] PDF salvo com sucesso: ${file.path}');

      return file;
    } catch (e) {
      print('âŒ [PDF] Erro ao exportar imagem para PDF: $e');
      rethrow;
    }
  }

  /// Exportar cÃ³digo como arquivo de texto
  Future<String?> exportCodeAsFile({
    required String code,
    required String language,
    required String fileName,
  }) async {
    print('ğŸ“ [PDF] Iniciando exportaÃ§Ã£o de cÃ³digo como arquivo...');
    try {
      print('ğŸ“ [PDF] Obtendo diretÃ³rio de downloads...');
      final downloadsDir = await _getDownloadsDirectory();
      final sanitizedFileName = _sanitizeFileName(fileName);
      final extension = _getFileExtension(language);
      final filePath =
          path.join(downloadsDir.path, '$sanitizedFileName.$extension');
      print('ğŸ“ [PDF] Caminho do arquivo: $filePath');

      print('ğŸ“ [PDF] Salvando arquivo...');
      final file = File(filePath);
      await file.writeAsString(code);
      print('âœ… [PDF] Arquivo salvo com sucesso: $filePath');

      return filePath;
    } catch (e) {
      print('âŒ [PDF] Erro ao exportar cÃ³digo como arquivo: $e');
      return null;
    }
  }

  /// Abrir arquivo exportado
  Future<void> openExportedFile(String filePath) async {
    print('ğŸ“‚ [PDF] Abrindo arquivo: $filePath');
    try {
      await OpenFile.open(filePath);
      print('âœ… [PDF] Arquivo aberto com sucesso');
    } catch (e) {
      print('âŒ [PDF] Erro ao abrir arquivo: $e');
    }
  }

  /// Obter diretÃ³rio de downloads
  Future<Directory> _getDownloadsDirectory() async {
    print('ğŸ“ [PDF] Obtendo diretÃ³rio de downloads...');
    Directory downloadsDir;

    if (Platform.isAndroid) {
      downloadsDir = Directory('/storage/emulated/0/Download');
      print('ğŸ“ [PDF] Android: $downloadsDir');
    } else if (Platform.isIOS) {
      downloadsDir = await getApplicationDocumentsDirectory();
      print('ğŸ“ [PDF] iOS: $downloadsDir');
    } else if (Platform.isWindows) {
      downloadsDir =
          Directory('${Platform.environment['USERPROFILE']}\\Downloads');
      print('ğŸ“ [PDF] Windows: $downloadsDir');
    } else if (Platform.isMacOS) {
      downloadsDir = Directory('${Platform.environment['HOME']}/Downloads');
      print('ğŸ“ [PDF] macOS: $downloadsDir');
    } else {
      downloadsDir = await getApplicationDocumentsDirectory();
      print('ğŸ“ [PDF] Outro: $downloadsDir');
    }

    print('ğŸ“ [PDF] DiretÃ³rio final: ${downloadsDir.path}');
    return downloadsDir;
  }

  /// Sanitizar nome de arquivo
  String _sanitizeFileName(String fileName) {
    final sanitized = fileName
        .replaceAll(RegExp(r'[<>:"/\\|?*]'), '_')
        .replaceAll(RegExp(r'\s+'), '_')
        .toLowerCase();
    print('ğŸ“ [PDF] Nome sanitizado: "$fileName" -> "$sanitized"');
    return sanitized;
  }

  /// Obter extensÃ£o de arquivo baseada na linguagem
  String _getFileExtension(String language) {
    final extensions = {
      'javascript': 'js',
      'typescript': 'ts',
      'python': 'py',
      'java': 'java',
      'cpp': 'cpp',
      'c': 'c',
      'csharp': 'cs',
      'php': 'php',
      'ruby': 'rb',
      'go': 'go',
      'rust': 'rs',
      'swift': 'swift',
      'kotlin': 'kt',
      'dart': 'dart',
      'html': 'html',
      'css': 'css',
      'sql': 'sql',
      'json': 'json',
      'xml': 'xml',
      'yaml': 'yaml',
      'markdown': 'md',
      'text': 'txt',
    };

    final extension = extensions[language.toLowerCase()] ?? 'txt';
    print('ğŸ“ [PDF] ExtensÃ£o para linguagem "$language": $extension');
    return extension;
  }

  /// Exportar markdown como PDF
  Future<String?> exportMarkdownAsPdf({
    required String markdown,
    required String title,
    String? author,
    String? subject,
  }) async {
    print('ğŸ“„ [PDF] ===== INICIANDO EXPORTAÃ‡ÃƒO MARKDOWN PARA PDF =====');
    print('ğŸ“„ [PDF] TÃ­tulo: $title');
    print('ğŸ“„ [PDF] Tamanho do markdown: ${markdown.length} caracteres');
    print('ğŸ“„ [PDF] Autor: $author');
    print('ğŸ“„ [PDF] Assunto: $subject');

    try {
      print('ğŸ“„ [PDF] Carregando fontes...');
      await _loadFonts();
      print('âœ… [PDF] Fontes carregadas com sucesso');

      print('ğŸ“„ [PDF] Criando documento PDF...');
      final pdf = pw.Document();
      print('âœ… [PDF] Documento PDF criado');

      print('ğŸ“„ [PDF] Sanitizando markdown...');
      String sanitizedMarkdown = _sanitizeText(markdown);
      print(
          'ğŸ“„ [PDF] Markdown sanitizado: ${sanitizedMarkdown.length} caracteres');

      print('ğŸ“„ [PDF] Parsing markdown com EnhancedMarkdownParser...');
      final blocks = EnhancedMarkdownParser.parseMarkdown(sanitizedMarkdown,
          enableHtmlEnhancements: true);
      print('ğŸ“„ [PDF] Blocos parseados: ${blocks.length} blocos');

      print('ğŸ“„ [PDF] Convertendo blocos para widgets PDF...');
      final contentWidgets = await _convertBlocksToPdfWidgets(blocks);
      print('ğŸ“„ [PDF] Widgets convertidos: ${contentWidgets.length} widgets');

      print('ğŸ“„ [PDF] Dividindo conteÃºdo em pÃ¡ginas...');
      final pages = _splitContentIntoPages(contentWidgets, title);
      print('ğŸ“„ [PDF] PÃ¡ginas criadas: ${pages.length} pÃ¡ginas');

      print('ğŸ“„ [PDF] Adicionando pÃ¡ginas ao PDF...');
      for (int i = 0; i < pages.length; i++) {
        print('ğŸ“„ [PDF] Adicionando pÃ¡gina ${i + 1}/${pages.length}');
        pdf.addPage(
          pw.Page(
            pageFormat: PdfPageFormat.a4,
            margin: const pw.EdgeInsets.all(40),
            build: (context) => pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                // CabeÃ§alho apenas na primeira pÃ¡gina
                if (i == 0) ...[
                  pw.Text(
                    title,
                    style: pw.TextStyle(
                      fontSize: 24,
                      fontWeight: pw.FontWeight.bold,
                      font: _getDefaultFont(),
                      fontFallback: _getFontFallbacks(),
                    ),
                  ),
                  pw.SizedBox(height: 20),
                  pw.Divider(),
                  pw.SizedBox(height: 20),
                ],

                // ConteÃºdo da pÃ¡gina
                pw.Expanded(
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: pages[i],
                  ),
                ),

                // RodapÃ©
                pw.SizedBox(height: 20),
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    pw.Text(
                      'Bloquinho - $title',
                      style: pw.TextStyle(
                          fontSize: 10, color: pw.PdfColor.fromInt(0xFF888888)),
                    ),
                    pw.Text(
                      'PÃ¡gina ${i + 1} de ${pages.length}',
                      style: pw.TextStyle(
                          fontSize: 10, color: pw.PdfColor.fromInt(0xFF888888)),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      }
      print('âœ… [PDF] Todas as pÃ¡ginas adicionadas ao PDF');

      print('ğŸ“„ [PDF] Obtendo diretÃ³rio de downloads...');
      final downloadsDir = await _getDownloadsDirectory();
      final fileName =
          '${_sanitizeFileName(title)}_${DateTime.now().millisecondsSinceEpoch}.pdf';
      final filePath = path.join(downloadsDir.path, fileName);
      print('ğŸ“„ [PDF] Caminho do arquivo: $filePath');

      print('ğŸ“„ [PDF] Salvando PDF...');
      final file = File(filePath);
      final pdfBytes = await pdf.save();
      print('ğŸ“„ [PDF] PDF gerado: ${pdfBytes.length} bytes');
      try {
        await file.writeAsBytes(pdfBytes);
        print('âœ… [PDF] PDF salvo com sucesso: $filePath');
      } catch (e) {
        print('âŒ [PDF] Erro ao salvar PDF no caminho $filePath: $e');
        print('âŒ [PDF] Verifique permissÃµes de diretÃ³rio ou espaÃ§o em disco.');
        return null;
      }

      return filePath;
    } catch (e, stackTrace) {
      print('âŒ [PDF] Erro ao exportar markdown como PDF: $e');
      print('âŒ [PDF] Stack trace: $stackTrace');
      return null;
    }
  }

  /// Converte um widget Flutter em uma imagem PNG (Uint8List)
  Future<Uint8List?> widgetToImage(fw.Widget widget,
      {double pixelRatio = 3.0, Size size = const Size(600, 100)}) async {
    // Esta funÃ§Ã£o Ã© um placeholder, pois nÃ£o Ã© possÃ­vel renderizar widgets fora do contexto do Flutter.
    // Em produÃ§Ã£o, use um mÃ©todo de renderizaÃ§Ã£o real, como screenshot do widget na Ã¡rvore de widgets.
    return null;
  }

  /// Gera uma imagem PNG de uma fÃ³rmula LaTeX usando flutter_math
  Future<Uint8List?> latexToImage(String latex, {bool isBlock = false}) async {
    // Placeholder: nÃ£o Ã© possÃ­vel gerar imagem LaTeX fora do contexto Flutter.
    return null;
  }

  /// Gera uma imagem PNG de um diagrama Mermaid usando a API kroki.io
  Future<Uint8List?> mermaidToImage(String mermaidCode) async {
    try {
      final response = await http.post(
        Uri.parse('https://kroki.io/mermaid/png'),
        headers: {'Content-Type': 'text/plain'},
        body: mermaidCode,
      );
      if (response.statusCode == 200) {
        return response.bodyBytes;
      } else {
        print('âŒ [PDF] Erro ao gerar imagem Mermaid: ${response.statusCode}');
        return null;
      }
    } catch (e) {
      print('âŒ [PDF] Erro ao gerar imagem Mermaid: $e');
      return null;
    }
  }

  /// Gera uma imagem PNG de um bloco de cÃ³digo (usando o widget do preview)
  Future<Uint8List?> codeBlockToImage(String code, String language) async {
    // Placeholder: nÃ£o Ã© possÃ­vel gerar imagem do widget fora do contexto Flutter.
    return null;
  }

  /// Substitui emojis por texto alternativo
  String _replaceEmojisWithText(String text) {
    final emojiMap = {
      'ğŸ“Š': '[DIAGRAMA]',
      'ğŸ¨': '[ARTE]',
      'ğŸ’»': '[CÃ“DIGO]',
      'ğŸ”¢': '[MATEMÃTICA]',
      'ğŸ“': '[DOCUMENTO]',
      'ğŸ“ˆ': '[GRÃFICO]',
      'ğŸ”§': '[FERRAMENTA]',
      'âœ…': '[OK]',
      'âŒ': '[ERRO]',
      'âš ï¸': '[AVISO]',
      'ğŸ’¡': '[IDÃ‰IA]',
      'ğŸš€': '[LANÃ‡AMENTO]',
      'ğŸ¯': '[OBJETIVO]',
      'ğŸ“š': '[LIVRO]',
      'ğŸ”': '[BUSCA]',
      'âš¡': '[RÃPIDO]',
      'ğŸŒŸ': '[ESTRELA]',
      'ğŸ’ª': '[FORÃ‡A]',
      'ğŸ‰': '[CELEBRAÃ‡ÃƒO]',
      'ğŸ”¥': '[FOGO]',
      'ğŸ“±': '[MOBILE]',
      'ğŸ’»': '[COMPUTADOR]',
      'ğŸŒ': '[WEB]',
      'ğŸ”': '[SEGURANÃ‡A]',
      'ğŸ“Š': '[ESTATÃSTICA]',
      'ğŸ®': '[JOGO]',
      'ğŸµ': '[MÃšSICA]',
      'ğŸ“·': '[FOTO]',
      'ğŸ¬': '[VÃDEO]',
      'ğŸ“': '[TELEFONE]',
      'ğŸ“§': '[EMAIL]',
      'ğŸ’¼': '[TRABALHO]',
      'ğŸ ': '[CASA]',
      'ğŸš—': '[CARRO]',
      'âœˆï¸': '[AVIÃƒO]',
      'ğŸš‡': '[METRÃ”]',
      'ğŸšŒ': '[Ã”NIBUS]',
      'ğŸš²': '[BICICLETA]',
      'ğŸƒ': '[CORRIDA]',
      'ğŸ‹ï¸': '[MUSCULAÃ‡ÃƒO]',
      'âš½': '[FUTEBOL]',
      'ğŸ€': '[BASQUETE]',
      'ğŸ¾': '[TÃŠNIS]',
      'ğŸŠ': '[NATAÃ‡ÃƒO]',
      'ğŸ¯': '[ALVO]',
      'ğŸª': '[CIRCO]',
      'ğŸ­': '[TEATRO]',
      'ğŸ¤': '[MICROFONE]',
      'ğŸ§': '[FONES]',
      'ğŸ“º': '[TV]',
      'ğŸ®': '[GAME]',
      'ğŸ–¥ï¸': '[MONITOR]',
      'âŒ¨ï¸': '[TECLADO]',
      'ğŸ–±ï¸': '[MOUSE]',
      'ğŸ’¾': '[DISCO]',
      'ğŸ“€': '[CD]',
      'ğŸ’¿': '[DVD]',
      'ğŸ“¼': '[FITA]',
      'ğŸ“·': '[CÃ‚MERA]',
      'ğŸ“¹': '[VÃDEO]',
      'ğŸ¥': '[FILME]',
      'ğŸ“º': '[TV]',
      'ğŸ“»': '[RÃDIO]',
      'ğŸ™ï¸': '[MICROFONE]',
      'ğŸšï¸': '[CONTROLE]',
      'ğŸ›ï¸': '[KNOB]',
      'ğŸ“±': '[CELULAR]',
      'ğŸ“²': '[SMARTPHONE]',
      'â˜ï¸': '[TELEFONE]',
      'ğŸ“': '[TELEFONE]',
      'ğŸ“Ÿ': '[PAGER]',
      'ï¿½ï¿½': '[FAX]',
      'ğŸ”‹': '[BATERIA]',
      'ğŸ”Œ': '[PLUG]',
      'ğŸ’¡': '[LÃ‚MPADA]',
      'ğŸ”¦': '[LANTERNA]',
      'ğŸ•¯ï¸': '[VELA]',
      'ğŸª”': '[DIYA]',
      'ğŸ§¯': '[EXTINTOR]',
      'ğŸ›¢ï¸': '[Ã“LEO]',
      'ğŸ’¸': '[DINHEIRO]',
      'ğŸ’µ': '[NOTA]',
      'ğŸ’´': '[YEN]',
      'ğŸ’¶': '[EURO]',
      'ğŸ’·': '[LIBRA]',
      'ğŸ’°': '[BOLSA]',
      'ğŸ’³': '[CARTÃƒO]',
      'ğŸ’': '[DIAMANTE]',
      'âš–ï¸': '[BALANÃ‡A]',
      'ğŸªœ': '[ESCADA]',
      'ğŸ› ï¸': '[FERRAMENTAS]',
      'ğŸ”¨': '[MARTELO]',
      'âš’ï¸': '[MARTELO]',
      'ğŸª›': '[CHAVE]',
      'ğŸ”§': '[CHAVE]',
      'âš™ï¸': '[ENGRENAGEM]',
      'ğŸ—œï¸': '[COMPRESSOR]',
      'âš—ï¸': '[BALÃƒO]',
      'ğŸ§ª': '[TUBO]',
      'ğŸ§«': '[PLACA]',
      'ğŸ§¬': '[DNA]',
      'ğŸ”¬': '[MICROSCÃ“PIO]',
      'ğŸ”­': '[TELESCÃ“PIO]',
      'ğŸ“¡': '[SATELLITE]',
      'ğŸ’‰': '[SERINGA]',
      'ğŸ©¸': '[SANGUE]',
      'ğŸ’Š': '[PÃLULA]',
      'ğŸ©¹': '[CURATIVO]',
      'ğŸ©º': '[ESTETOSCÃ“PIO]',
      'ğŸ©»': '[RAIO-X]',
      'ğŸ©¼': '[MULETA]',
      'ğŸ©½': '[CADEIRA]',
      'ğŸ©¾': '[BRAÃ‡O]',
      'ğŸ©¿': '[PERNA]',
      'ğŸª–': '[CAPACETE]',
      'ğŸª—': '[ACORDEÃƒO]',
      'ğŸª˜': '[TAMBOR]',
      'ğŸª™': '[MOEDA]',
      'ğŸªš': '[SERRA]',
      'ğŸª›': '[CHAVE]',
      'ğŸªœ': '[ESCADA]',
      'ğŸª': '[GANCHO]',
      'ğŸª': '[ESPELHO]',
      'ğŸªŸ': '[JANELA]',
      'ğŸª ': '[DESENTUPIDOR]',
      'ğŸª¡': '[AGULHA]',
      'ğŸª¢': '[NÃ“]',
      'ğŸª£': '[BALDE]',
      'ğŸª¤': '[RATOEIRA]',
      'ğŸª¥': '[ESCOVA]',
      'ğŸª¦': '[TÃšMULO]',
      'ğŸª§': '[PLACA]',
      'ğŸª¨': '[ROCHA]',
      'ğŸª©': '[DISCO]',
      'ğŸªª': '[IDENTIDADE]',
      'ğŸª«': '[BATERIA]',
      'ğŸª¬': '[AMULETO]',
      'ğŸª­': '[LEQUE]',
      'ğŸª®': '[PENTE]',
      'ğŸª¯': '[RODA]',
      'ğŸª°': '[MOSCA]',
      'ğŸª±': '[MINHOCA]',
      'ğŸª²': '[BESOURO]',
      'ğŸª³': '[BARATA]',
      'ğŸª´': '[PLANTA]',
      'ğŸªµ': '[MADEIRA]',
      'ğŸª¶': '[PENA]',
      'ğŸª·': '[LÃ“TUS]',
      'ğŸª¸': '[CORAL]',
      'ğŸª¹': '[NINHO]',
      'ğŸªº': '[OVO]',
      'ğŸ«€': '[CORAÃ‡ÃƒO]',
      'ğŸ«': '[PULMÃƒO]',
      'ğŸ«‚': '[ABRAÃ‡O]',
      'ğŸ«ƒ': '[GRAVIDEZ]',
      'ğŸ«„': '[GRAVIDEZ]',
      'ğŸ«…': '[PESSOA]',
      'ğŸ«†': '[PESSOA]',
      'ğŸ«‡': '[PESSOA]',
      'ğŸ«ˆ': '[PESSOA]',
      'ğŸ«‰': '[PESSOA]',
      'ğŸ«Š': '[PESSOA]',
      'ğŸ«‹': '[PESSOA]',
      'ğŸ«Œ': '[PESSOA]',
      'ğŸ«': '[PESSOA]',
      'ğŸ«': '[PESSOA]',
      'ğŸ«': '[PESSOA]',
      'ğŸ«': '[MIRTILO]',
      'ğŸ«‘': '[PIMENTÃƒO]',
      'ğŸ«’': '[AZEITONA]',
      'ğŸ«“': '[PÃƒO]',
      'ğŸ«”': '[TAMALE]',
      'ğŸ«•': '[FONDUE]',
      'ğŸ«–': '[CHALEIRA]',
      'ğŸ«—': '[BEBIDA]',
      'ğŸ«˜': '[FEIJÃƒO]',
      'ğŸ«™': '[JARRO]',
      'ğŸ«š': '[GENGIBRE]',
      'ğŸ«›': '[ERVILHA]',
      'ğŸ«œ': '[FOLHA]',
      'ğŸ«': '[FOLHA]',
      'ğŸ«': '[FOLHA]',
      'ğŸ«Ÿ': '[FOLHA]',
      'ğŸ« ': '[DERRETENDO]',
      'ğŸ«¡': '[SALUTA]',
      'ğŸ«¢': '[SURPRESO]',
      'ğŸ«£': '[ESPIANDO]',
      'ğŸ«¤': '[NEUTRO]',
      'ğŸ«¥': '[LINHA]',
      'ğŸ«¦': '[MORDENDO]',
      'ğŸ«§': '[BOLHAS]',
      'ğŸ«¨': '[TREMENDO]',
      'ğŸ«©': '[PESSOA]',
      'ğŸ«ª': '[PESSOA]',
      'ğŸ««': '[PESSOA]',
      'ğŸ«¬': '[PESSOA]',
      'ğŸ«­': '[PESSOA]',
      'ğŸ«®': '[PESSOA]',
      'ğŸ«¯': '[PESSOA]',
      'ğŸ«°': '[PESSOA]',
      'ğŸ«±': '[PESSOA]',
      'ğŸ«²': '[PESSOA]',
      'ğŸ«³': '[PESSOA]',
      'ğŸ«´': '[PESSOA]',
      'ğŸ«µ': '[PESSOA]',
      'ğŸ«¶': '[PESSOA]',
      'ğŸ«·': '[PESSOA]',
      'ğŸ«¸': '[PESSOA]',
      'ğŸ«¹': '[PESSOA]',
      'ğŸ«º': '[PESSOA]',
      'ğŸ«»': '[PESSOA]',
      'ğŸ«¼': '[PESSOA]',
      'ğŸ«½': '[PESSOA]',
      'ğŸ«¾': '[PESSOA]',
      'ğŸ«¿': '[PESSOA]',
      'ğŸ¬€': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬‚': '[SÃMBOLO]',
      'ğŸ¬ƒ': '[SÃMBOLO]',
      'ğŸ¬„': '[SÃMBOLO]',
      'ğŸ¬…': '[SÃMBOLO]',
      'ğŸ¬†': '[SÃMBOLO]',
      'ğŸ¬‡': '[SÃMBOLO]',
      'ğŸ¬ˆ': '[SÃMBOLO]',
      'ğŸ¬‰': '[SÃMBOLO]',
      'ğŸ¬Š': '[SÃMBOLO]',
      'ğŸ¬‹': '[SÃMBOLO]',
      'ğŸ¬Œ': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬‘': '[SÃMBOLO]',
      'ğŸ¬’': '[SÃMBOLO]',
      'ğŸ¬“': '[SÃMBOLO]',
      'ğŸ¬”': '[SÃMBOLO]',
      'ğŸ¬•': '[SÃMBOLO]',
      'ğŸ¬–': '[SÃMBOLO]',
      'ğŸ¬—': '[SÃMBOLO]',
      'ğŸ¬˜': '[SÃMBOLO]',
      'ğŸ¬™': '[SÃMBOLO]',
      'ğŸ¬š': '[SÃMBOLO]',
      'ğŸ¬›': '[SÃMBOLO]',
      'ğŸ¬œ': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬': '[SÃMBOLO]',
      'ğŸ¬Ÿ': '[SÃMBOLO]',
      'ğŸ¬ ': '[SÃMBOLO]',
      'ğŸ¬¡': '[SÃMBOLO]',
      'ğŸ¬¢': '[SÃMBOLO]',
      'ğŸ¬£': '[SÃMBOLO]',
      'ğŸ¬¤': '[SÃMBOLO]',
      'ğŸ¬¥': '[SÃMBOLO]',
      'ğŸ¬¦': '[SÃMBOLO]',
      'ğŸ¬§': '[SÃMBOLO]',
      'ğŸ¬¨': '[SÃMBOLO]',
      'ğŸ¬©': '[SÃMBOLO]',
      'ğŸ¬ª': '[SÃMBOLO]',
      'ğŸ¬«': '[SÃMBOLO]',
      'ğŸ¬¬': '[SÃMBOLO]',
      'ğŸ¬­': '[SÃMBOLO]',
      'ğŸ¬®': '[SÃMBOLO]',
      'ğŸ¬¯': '[SÃMBOLO]',
      'ğŸ¬°': '[SÃMBOLO]',
      'ğŸ¬±': '[SÃMBOLO]',
      'ğŸ¬²': '[SÃMBOLO]',
      'ğŸ¬³': '[SÃMBOLO]',
      'ğŸ¬´': '[SÃMBOLO]',
      'ğŸ¬µ': '[SÃMBOLO]',
      'ğŸ¬¶': '[SÃMBOLO]',
      'ğŸ¬·': '[SÃMBOLO]',
      'ğŸ¬¸': '[SÃMBOLO]',
      'ğŸ¬¹': '[SÃMBOLO]',
      'ğŸ¬º': '[SÃMBOLO]',
      'ğŸ¬»': '[SÃMBOLO]',
      'ğŸ¬¼': '[SÃMBOLO]',
      'ğŸ¬½': '[SÃMBOLO]',
      'ğŸ¬¾': '[SÃMBOLO]',
      'ğŸ¬¿': '[SÃMBOLO]',
      'ğŸ­€': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­‚': '[SÃMBOLO]',
      'ğŸ­ƒ': '[SÃMBOLO]',
      'ğŸ­„': '[SÃMBOLO]',
      'ğŸ­…': '[SÃMBOLO]',
      'ğŸ­†': '[SÃMBOLO]',
      'ğŸ­‡': '[SÃMBOLO]',
      'ğŸ­ˆ': '[SÃMBOLO]',
      'ğŸ­‰': '[SÃMBOLO]',
      'ğŸ­Š': '[SÃMBOLO]',
      'ğŸ­‹': '[SÃMBOLO]',
      'ğŸ­Œ': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­‘': '[SÃMBOLO]',
      'ğŸ­’': '[SÃMBOLO]',
      'ğŸ­“': '[SÃMBOLO]',
      'ğŸ­”': '[SÃMBOLO]',
      'ğŸ­•': '[SÃMBOLO]',
      'ğŸ­–': '[SÃMBOLO]',
      'ğŸ­—': '[SÃMBOLO]',
      'ğŸ­˜': '[SÃMBOLO]',
      'ğŸ­™': '[SÃMBOLO]',
      'ğŸ­š': '[SÃMBOLO]',
      'ğŸ­›': '[SÃMBOLO]',
      'ğŸ­œ': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­': '[SÃMBOLO]',
      'ğŸ­Ÿ': '[SÃMBOLO]',
      'ğŸ­ ': '[SÃMBOLO]',
      'ğŸ­¡': '[SÃMBOLO]',
      'ğŸ­¢': '[SÃMBOLO]',
      'ğŸ­£': '[SÃMBOLO]',
      'ğŸ­¤': '[SÃMBOLO]',
      'ğŸ­¥': '[SÃMBOLO]',
      'ğŸ­¦': '[SÃMBOLO]',
      'ğŸ­§': '[SÃMBOLO]',
      'ğŸ­¨': '[SÃMBOLO]',
      'ğŸ­©': '[SÃMBOLO]',
      'ğŸ­ª': '[SÃMBOLO]',
      'ğŸ­«': '[SÃMBOLO]',
      'ğŸ­¬': '[SÃMBOLO]',
      'ğŸ­­': '[SÃMBOLO]',
      'ğŸ­®': '[SÃMBOLO]',
      'ğŸ­¯': '[SÃMBOLO]',
      'ğŸ­°': '[SÃMBOLO]',
      'ğŸ­±': '[SÃMBOLO]',
      'ğŸ­²': '[SÃMBOLO]',
      'ğŸ­³': '[SÃMBOLO]',
      'ğŸ­´': '[SÃMBOLO]',
      'ğŸ­µ': '[SÃMBOLO]',
      'ğŸ­¶': '[SÃMBOLO]',
      'ğŸ­·': '[SÃMBOLO]',
      'ğŸ­¸': '[SÃMBOLO]',
      'ğŸ­¹': '[SÃMBOLO]',
      'ğŸ­º': '[SÃMBOLO]',
      'ğŸ­»': '[SÃMBOLO]',
      'ğŸ­¼': '[SÃMBOLO]',
      'ğŸ­½': '[SÃMBOLO]',
      'ğŸ­¾': '[SÃMBOLO]',
      'ğŸ­¿': '[SÃMBOLO]',
      'ğŸ®€': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®‚': '[SÃMBOLO]',
      'ğŸ®ƒ': '[SÃMBOLO]',
      'ğŸ®„': '[SÃMBOLO]',
      'ğŸ®…': '[SÃMBOLO]',
      'ğŸ®†': '[SÃMBOLO]',
      'ğŸ®‡': '[SÃMBOLO]',
      'ğŸ®ˆ': '[SÃMBOLO]',
      'ğŸ®‰': '[SÃMBOLO]',
      'ğŸ®Š': '[SÃMBOLO]',
      'ğŸ®‹': '[SÃMBOLO]',
      'ğŸ®Œ': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®‘': '[SÃMBOLO]',
      'ğŸ®’': '[SÃMBOLO]',
      'ğŸ®“': '[SÃMBOLO]',
      'ğŸ®”': '[SÃMBOLO]',
      'ğŸ®•': '[SÃMBOLO]',
      'ğŸ®–': '[SÃMBOLO]',
      'ğŸ®—': '[SÃMBOLO]',
      'ğŸ®˜': '[SÃMBOLO]',
      'ğŸ®™': '[SÃMBOLO]',
      'ğŸ®š': '[SÃMBOLO]',
      'ğŸ®›': '[SÃMBOLO]',
      'ğŸ®œ': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®': '[SÃMBOLO]',
      'ğŸ®Ÿ': '[SÃMBOLO]',
      'ğŸ® ': '[SÃMBOLO]',
      'ğŸ®¡': '[SÃMBOLO]',
      'ğŸ®¢': '[SÃMBOLO]',
      'ğŸ®£': '[SÃMBOLO]',
      'ğŸ®¤': '[SÃMBOLO]',
      'ğŸ®¥': '[SÃMBOLO]',
      'ğŸ®¦': '[SÃMBOLO]',
      'ğŸ®§': '[SÃMBOLO]',
      'ğŸ®¨': '[SÃMBOLO]',
      'ğŸ®©': '[SÃMBOLO]',
      'ğŸ®ª': '[SÃMBOLO]',
      'ğŸ®«': '[SÃMBOLO]',
      'ğŸ®¬': '[SÃMBOLO]',
      'ğŸ®­': '[SÃMBOLO]',
      'ğŸ®®': '[SÃMBOLO]',
      'ğŸ®¯': '[SÃMBOLO]',
      'ğŸ®°': '[SÃMBOLO]',
      'ğŸ®±': '[SÃMBOLO]',
      'ğŸ®²': '[SÃMBOLO]',
      'ğŸ®³': '[SÃMBOLO]',
      'ğŸ®´': '[SÃMBOLO]',
      'ğŸ®µ': '[SÃMBOLO]',
      'ğŸ®¶': '[SÃMBOLO]',
      'ğŸ®·': '[SÃMBOLO]',
      'ğŸ®¸': '[SÃMBOLO]',
      'ğŸ®¹': '[SÃMBOLO]',
      'ğŸ®º': '[SÃMBOLO]',
      'ğŸ®»': '[SÃMBOLO]',
      'ğŸ®¼': '[SÃMBOLO]',
      'ğŸ®½': '[SÃMBOLO]',
      'ğŸ®¾': '[SÃMBOLO]',
      'ğŸ®¿': '[SÃMBOLO]',
      'ğŸ¯€': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯‚': '[SÃMBOLO]',
      'ğŸ¯ƒ': '[SÃMBOLO]',
      'ğŸ¯„': '[SÃMBOLO]',
      'ğŸ¯…': '[SÃMBOLO]',
      'ğŸ¯†': '[SÃMBOLO]',
      'ğŸ¯‡': '[SÃMBOLO]',
      'ğŸ¯ˆ': '[SÃMBOLO]',
      'ğŸ¯‰': '[SÃMBOLO]',
      'ğŸ¯Š': '[SÃMBOLO]',
      'ğŸ¯‹': '[SÃMBOLO]',
      'ğŸ¯Œ': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯‘': '[SÃMBOLO]',
      'ğŸ¯’': '[SÃMBOLO]',
      'ğŸ¯“': '[SÃMBOLO]',
      'ğŸ¯”': '[SÃMBOLO]',
      'ğŸ¯•': '[SÃMBOLO]',
      'ğŸ¯–': '[SÃMBOLO]',
      'ğŸ¯—': '[SÃMBOLO]',
      'ğŸ¯˜': '[SÃMBOLO]',
      'ğŸ¯™': '[SÃMBOLO]',
      'ğŸ¯š': '[SÃMBOLO]',
      'ğŸ¯›': '[SÃMBOLO]',
      'ğŸ¯œ': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯': '[SÃMBOLO]',
      'ğŸ¯Ÿ': '[SÃMBOLO]',
      'ğŸ¯ ': '[SÃMBOLO]',
      'ğŸ¯¡': '[SÃMBOLO]',
      'ğŸ¯¢': '[SÃMBOLO]',
      'ğŸ¯£': '[SÃMBOLO]',
      'ğŸ¯¤': '[SÃMBOLO]',
      'ğŸ¯¥': '[SÃMBOLO]',
      'ğŸ¯¦': '[SÃMBOLO]',
      'ğŸ¯§': '[SÃMBOLO]',
      'ğŸ¯¨': '[SÃMBOLO]',
      'ğŸ¯©': '[SÃMBOLO]',
      'ğŸ¯ª': '[SÃMBOLO]',
      'ğŸ¯«': '[SÃMBOLO]',
      'ğŸ¯¬': '[SÃMBOLO]',
      'ğŸ¯­': '[SÃMBOLO]',
      'ğŸ¯®': '[SÃMBOLO]',
      'ğŸ¯¯': '[SÃMBOLO]',
      'ğŸ¯°': '[SÃMBOLO]',
      'ğŸ¯±': '[SÃMBOLO]',
      'ğŸ¯²': '[SÃMBOLO]',
      'ğŸ¯³': '[SÃMBOLO]',
      'ğŸ¯´': '[SÃMBOLO]',
      'ğŸ¯µ': '[SÃMBOLO]',
      'ğŸ¯¶': '[SÃMBOLO]',
      'ğŸ¯·': '[SÃMBOLO]',
      'ğŸ¯¸': '[SÃMBOLO]',
      'ğŸ¯¹': '[SÃMBOLO]',
      'ğŸ¯º': '[SÃMBOLO]',
      'ğŸ¯»': '[SÃMBOLO]',
      'ğŸ¯¼': '[SÃMBOLO]',
      'ğŸ¯½': '[SÃMBOLO]',
      'ğŸ¯¾': '[SÃMBOLO]',
      'ğŸ¯¿': '[SÃMBOLO]',
    };

    String result = text;

    // Primeiro, remover caracteres de controle problemÃ¡ticos
    result =
        result.replaceAll(RegExp(r'\uFE0F\uFE0E'), ''); // Variation Selectors

    // Substituir emojis conhecidos
    emojiMap.forEach((emoji, replacement) {
      result = result.replaceAll(emoji, replacement);
    });

    // Remover outros caracteres Unicode problemÃ¡ticos
    result = result.replaceAll(
        RegExp(r'\u{1F600}-\u{1F64F}]'), '[EMOJI]'); // Emojis faciais
    result = result.replaceAll(
        RegExp(r'\u{1F300}-\u{1F5FF}]'), '[SÃMBOLO]'); // Misc Symbols
    result = result.replaceAll(
        RegExp(r'\u{1F680}-\u{1F6FF}]'), '[TRANSPORTE]'); // Transport
    result = result.replaceAll(
        RegExp(r'\u{1F1}-\u{1FF}'), '[BANDEIRA]'); // Regional Indicators
    result = result.replaceAll(
        RegExp(r'\u{2600}-\u{26FF}'), '[SÃMBOLO]'); // Misc Symbols
    result = result.replaceAll(
        RegExp(r'\u{2700}-\u{27BF}'), '[SÃMBOLO]'); // Dingbats

    return result;
  }

  /// --- REFATORADO: Converter blocos markdown para widgets PDF ---
  Future<List<pw.Widget>> _convertBlocksToPdfWidgets(
      List<MarkdownBlock> blocks) async {
    print('ğŸ”„ [PDF] Convertendo ${blocks.length} blocos para widgets PDF...');
    final widgets = <pw.Widget>[];
    for (int i = 0; i < blocks.length; i++) {
      final block = blocks[i];
      print(
          'ğŸ”„ [PDF] Processando bloco ${i + 1}/${blocks.length}: ${block.type}');
      try {
        switch (block.type) {
          case BlockType.heading:
            widgets.add(_createHeading(
                _replaceEmojisWithText(block.content), block.level!));
            widgets.add(pw.SizedBox(height: _getHeadingSpacing(block.level!)));
            break;
          case BlockType.paragraph:
            // LaTeX inline
            if (block.content.trim().startsWith('LATEX:')) {
              final latex = block.content.replaceFirst('LATEX:', '').trim();
              final img = await latexToImage(latex, isBlock: false);
              if (img != null) {
                widgets.add(pw.Image(pw.MemoryImage(img)));
              } else {
                widgets.add(
                    _createParagraph(_replaceEmojisWithText(block.content)));
              }
            } else {
              widgets
                  .add(_createParagraph(_replaceEmojisWithText(block.content)));
            }
            widgets.add(pw.SizedBox(height: 12));
            break;
          case BlockType.listItem:
            widgets.add(_createListItem(
                _replaceEmojisWithText(block.content), block.listType!));
            widgets.add(pw.SizedBox(height: 4));
            break;
          case BlockType.code:
            if ((block.language?.toLowerCase() ?? '') == 'mermaid') {
              final img = await mermaidToImage(block.content);
              if (img != null) {
                widgets.add(pw.Image(pw.MemoryImage(img)));
              } else {
                widgets.add(_createMermaidPlaceholder(block.content));
              }
            } else {
              final img =
                  await codeBlockToImage(block.content, block.language ?? '');
              if (img != null) {
                widgets.add(pw.Image(pw.MemoryImage(img)));
              } else {
                widgets
                    .add(_createCodeBlock(block.content, block.language ?? ''));
              }
            }
            widgets.add(pw.SizedBox(height: 16));
            break;
          case BlockType.blockquote:
            widgets
                .add(_createBlockquote(_replaceEmojisWithText(block.content)));
            widgets.add(pw.SizedBox(height: 16));
            break;
          case BlockType.table:
            widgets.add(_createTable(_replaceEmojisWithText(block.content)));
            widgets.add(pw.SizedBox(height: 16));
            break;
          case BlockType.horizontalRule:
            widgets.add(_createHorizontalRule());
            widgets.add(pw.SizedBox(height: 16));
            break;
        }
      } catch (e) {
        print('âŒ [PDF] Erro ao processar bloco ${i + 1}: $e');
        widgets.add(pw.Text('Erro ao processar conteÃºdo'));
      }
    }
    print('âœ… [PDF] ConversÃ£o concluÃ­da: ${widgets.length} widgets criados');
    return widgets;
  }

  /// Criar tÃ­tulo
  pw.Widget _createHeading(String text, int level) {
    print(
        'ğŸ“ [PDF] Criando heading nÃ­vel $level: "${text.substring(0, text.length > 50 ? 50 : text.length)}..."');
    final fontSize = _getHeadingFontSize(level);
    final fontWeight = pw.FontWeight.bold;

    // Processar elementos inline
    final inlineElements = EnhancedMarkdownParser.parseInlineText(text);
    final spans = <pw.InlineSpan>[];

    for (final element in inlineElements) {
      spans.add(_createInlineSpan(element, fontSize, fontWeight));
    }

    return pw.RichText(
      text: pw.TextSpan(children: spans),
    );
  }

  /// Criar parÃ¡grafo
  pw.Widget _createParagraph(String text) {
    print(
        'ğŸ“ [PDF] Criando parÃ¡grafo: "${text.substring(0, text.length > 50 ? 50 : text.length)}..."');
    // Processar elementos inline
    final inlineElements = EnhancedMarkdownParser.parseInlineText(text);
    final spans = <pw.InlineSpan>[];

    for (final element in inlineElements) {
      spans.add(_createInlineSpan(element, 14, pw.FontWeight.normal));
    }

    return pw.RichText(
      text: pw.TextSpan(children: spans),
    );
  }

  /// Criar item de lista
  pw.Widget _createListItem(String text, ListType listType) {
    print(
        'ğŸ“ [PDF] Criando item de lista: "${text.substring(0, text.length > 50 ? 50 : text.length)}..."');
    final inlineElements = EnhancedMarkdownParser.parseInlineText(text);
    final spans = <pw.InlineSpan>[];

    for (final element in inlineElements) {
      spans.add(_createInlineSpan(element, 14, pw.FontWeight.normal));
    }

    return pw.Row(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Container(
          width: 6,
          height: 6,
          margin: const pw.EdgeInsets.only(top: 8, right: 12),
          decoration: const pw.BoxDecoration(
            color: pw.PdfColor.fromInt(0xFF007BFF),
            shape: pw.BoxShape.circle,
          ),
        ),
        pw.Expanded(
          child: pw.RichText(
            text: pw.TextSpan(children: spans),
          ),
        ),
      ],
    );
  }

  /// Criar bloco de cÃ³digo
  pw.Widget _createCodeBlock(String code, String language) {
    print(
        'ğŸ“ [PDF] Criando bloco de cÃ³digo $language: ${code.length} caracteres');
    return pw.Container(
      width: double.infinity,
      padding: const pw.EdgeInsets.all(16),
      margin: const pw.EdgeInsets.symmetric(vertical: 8),
      decoration: pw.BoxDecoration(
        color: pw.PdfColor.fromInt(0xFF282C34),
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(12)),
        border: pw.Border.all(color: pw.PdfColor.fromInt(0xFF44475A)),
        boxShadow: [
          pw.BoxShadow(
            color: pw.PdfColor.fromInt(0xFF282C34),
            blurRadius: 8,
            offset: const pw.PdfPoint(0.0, 2.0),
          ),
        ],
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          if (language.isNotEmpty) ...[
            pw.Container(
              padding:
                  const pw.EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: pw.BoxDecoration(
                color: pw.PdfColor.fromInt(0xFF44475A),
                borderRadius: const pw.BorderRadius.all(pw.Radius.circular(6)),
              ),
              child: pw.Text(
                language.toUpperCase(),
                style: pw.TextStyle(
                  fontSize: 11,
                  fontWeight: pw.FontWeight.bold,
                  color: pw.PdfColor.fromInt(0xFF888888),
                  font: _getDefaultFont(),
                  fontFallback: _getFontFallbacks(),
                ),
              ),
            ),
            pw.SizedBox(height: 12),
          ],
          pw.Text(
            code,
            style: pw.TextStyle(
              fontSize: 12,
              color: pw.PdfColor.fromInt(0xFFE0E0E0),
              height: 1.4,
              font: _getDefaultFont(),
              fontFallback: _getFontFallbacks(),
            ),
          ),
        ],
      ),
    );
  }

  /// Criar blockquote
  pw.Widget _createBlockquote(String text) {
    print(
        'ğŸ“ [PDF] Criando blockquote: "${text.substring(0, text.length > 50 ? 50 : text.length)}..."');
    final inlineElements = EnhancedMarkdownParser.parseInlineText(text);
    final spans = <pw.InlineSpan>[];

    for (final element in inlineElements) {
      spans.add(_createInlineSpan(element, 14, pw.FontWeight.normal));
    }

    return pw.Container(
      width: double.infinity,
      padding: const pw.EdgeInsets.all(16),
      margin: const pw.EdgeInsets.symmetric(vertical: 8),
      decoration: pw.BoxDecoration(
        border: pw.Border(
          left: pw.BorderSide(
            color: pw.PdfColor.fromInt(0xFF007BFF),
            width: 4,
          ),
        ),
        color: pw.PdfColor.fromInt(0xFF282C34),
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(8)),
      ),
      child: pw.RichText(
        text: pw.TextSpan(children: spans),
      ),
    );
  }

  /// Criar tabela
  pw.Widget _createTable(String tableContent) {
    print('ğŸ“ [PDF] Criando tabela: ${tableContent.length} caracteres');
    final rows = tableContent.split('\n');
    if (rows.isEmpty) return pw.SizedBox.shrink();

    final tableRows = <pw.TableRow>[];

    for (int i = 0; i < rows.length; i++) {
      final row = rows[i];
      final cells = row.split('|').map((cell) => cell.trim()).toList();

      // Remover cÃ©lulas vazias no inÃ­cio e fim
      if (cells.isNotEmpty && cells.first.isEmpty) cells.removeAt(0);
      if (cells.isNotEmpty && cells.last.isEmpty)
        cells.removeAt(cells.length - 1);

      final tableCells = <pw.Widget>[];
      for (final cell in cells) {
        final isHeader = i == 0; // Primeira linha Ã© cabeÃ§alho
        tableCells.add(
          pw.Container(
            padding: const pw.EdgeInsets.all(8),
            decoration: pw.BoxDecoration(
              color: isHeader ? pw.PdfColor.fromInt(0xFF44475A) : null,
            ),
            child: pw.Text(
              cell,
              style: pw.TextStyle(
                fontWeight:
                    isHeader ? pw.FontWeight.bold : pw.FontWeight.normal,
                fontSize: 12,
                font: _getDefaultFont(),
                fontFallback: _getFontFallbacks(),
              ),
            ),
          ),
        );
      }

      tableRows.add(pw.TableRow(children: tableCells));
    }

    return pw.Table(
      border: pw.TableBorder.all(color: pw.PdfColor.fromInt(0xFF44475A)),
      children: tableRows,
    );
  }

  /// Criar linha horizontal
  pw.Widget _createHorizontalRule() {
    print('ğŸ“ [PDF] Criando linha horizontal');
    return pw.Container(
      height: 1,
      color: pw.PdfColor.fromInt(0xFF44475A),
    );
  }

  /// Criar placeholder para diagrama Mermaid
  pw.Widget _createMermaidPlaceholder(String mermaidCode) {
    print(
        'ğŸ“ [PDF] Criando placeholder para Mermaid: ${mermaidCode.length} caracteres');
    return pw.Container(
      width: double.infinity,
      padding: const pw.EdgeInsets.all(20),
      margin: const pw.EdgeInsets.symmetric(vertical: 8),
      decoration: pw.BoxDecoration(
        color: pw.PdfColor.fromInt(0xFF282C34),
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(12)),
        border: pw.Border.all(color: pw.PdfColor.fromInt(0xFF007BFF), width: 2),
        boxShadow: [
          pw.BoxShadow(
            color: pw.PdfColor.fromInt(0xFF44475A),
            blurRadius: 4,
            offset: const pw.PdfPoint(0.0, 2.0),
          ),
        ],
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          // CabeÃ§alho do diagrama
          pw.Row(
            children: [
              pw.Container(
                padding:
                    const pw.EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: pw.BoxDecoration(
                  color: pw.PdfColor.fromInt(0xFF007BFF),
                  borderRadius:
                      const pw.BorderRadius.all(pw.Radius.circular(6)),
                ),
                child: pw.Text(
                  'ğŸ“Š DIAGRAMA MERMAID',
                  style: pw.TextStyle(
                    fontSize: 12,
                    fontWeight: pw.FontWeight.bold,
                    color: pw.PdfColor.fromInt(0xFFFFFFFF),
                    font: _getDefaultFont(),
                    fontFallback: _getFontFallbacks(),
                  ),
                ),
              ),
            ],
          ),
          pw.SizedBox(height: 12),

          // ExplicaÃ§Ã£o
          pw.Text(
            'Este documento contÃ©m um diagrama Mermaid interativo.',
            style: pw.TextStyle(
              fontSize: 14,
              fontWeight: pw.FontWeight.bold,
              color: pw.PdfColor.fromInt(0xFFFFFFFF),
              font: _getDefaultFont(),
              fontFallback: _getFontFallbacks(),
            ),
          ),
          pw.SizedBox(height: 8),
          pw.Text(
            'Para visualizar este diagrama, abra o documento original no Bloquinho.',
            style: pw.TextStyle(
              fontSize: 12,
              color: pw.PdfColor.fromInt(0xFF888888),
              font: _getDefaultFont(),
              fontFallback: _getFontFallbacks(),
            ),
          ),
          pw.SizedBox(height: 12),

          // CÃ³digo do diagrama
          pw.Container(
            width: double.infinity,
            padding: const pw.EdgeInsets.all(12),
            decoration: pw.BoxDecoration(
              color: pw.PdfColor.fromInt(0xFF282C34),
              borderRadius: const pw.BorderRadius.all(pw.Radius.circular(8)),
              border: pw.Border.all(color: pw.PdfColor.fromInt(0xFF44475A)),
            ),
            child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text(
                  'CÃ³digo Mermaid:',
                  style: pw.TextStyle(
                    fontSize: 11,
                    fontWeight: pw.FontWeight.bold,
                    color: pw.PdfColor.fromInt(0xFF888888),
                    font: _getDefaultFont(),
                    fontFallback: _getFontFallbacks(),
                  ),
                ),
                pw.SizedBox(height: 6),
                pw.Text(
                  mermaidCode,
                  style: pw.TextStyle(
                    fontSize: 10,
                    color: pw.PdfColor.fromInt(0xFFE0E0E0),
                    height: 1.4,
                    font: _getDefaultFont(),
                    fontFallback: _getFontFallbacks(),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  /// Criar widget LaTeX renderizado
  pw.Widget _createLatexWidget(String latexCode, {bool isBlock = false}) {
    print(
        'ğŸ“ [PDF] Criando LaTeX ${isBlock ? 'bloco' : 'inline'}: ${latexCode.length} caracteres');

    return pw.Container(
      width: isBlock ? double.infinity : null,
      padding: isBlock
          ? const pw.EdgeInsets.all(16)
          : const pw.EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      margin: isBlock
          ? const pw.EdgeInsets.symmetric(vertical: 8)
          : pw.EdgeInsets.zero,
      decoration: isBlock
          ? pw.BoxDecoration(
              color: pw.PdfColor.fromInt(0xFF6272A4),
              borderRadius: const pw.BorderRadius.all(pw.Radius.circular(8)),
              border: pw.Border.all(color: pw.PdfColor.fromInt(0xFF888888)),
            )
          : null,
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          if (isBlock) ...[
            pw.Row(
              children: [
                pw.Container(
                  padding:
                      const pw.EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: pw.BoxDecoration(
                    color: pw.PdfColor.fromInt(0xFF888888),
                    borderRadius:
                        const pw.BorderRadius.all(pw.Radius.circular(4)),
                  ),
                  child: pw.Text(
                    'âˆ‘ LaTeX',
                    style: pw.TextStyle(
                      fontSize: 10,
                      fontWeight: pw.FontWeight.bold,
                      color: pw.PdfColor.fromInt(0xFFFFFFFF),
                      font: _getDefaultFont(),
                      fontFallback: _getFontFallbacks(),
                    ),
                  ),
                ),
              ],
            ),
            pw.SizedBox(height: 8),
          ],

          // FÃ³rmula formatada
          pw.Text(
            latexCode,
            style: pw.TextStyle(
              fontSize: isBlock ? 16 : 14,
              fontStyle: pw.FontStyle.italic,
              color: pw.PdfColor.fromInt(0xFFE0E0E0),
              fontWeight: pw.FontWeight.bold,
              font: _getDefaultFont(),
              fontFallback: _getFontFallbacks(),
            ),
          ),
        ],
      ),
    );
  }

  /// Converter Color do Flutter para PdfColor
  PdfColor _convertFlutterColorToPdfColor(Color? flutterColor) {
    if (flutterColor == null) return pw.PdfColors.black;

    // Usar os valores RGB da cor do Flutter
    final red = flutterColor.red / 255.0;
    final green = flutterColor.green / 255.0;
    final blue = flutterColor.blue / 255.0;

    return PdfColor(red, green, blue);
  }

  /// Converter FontWeight do Flutter para PDF
  pw.FontWeight _convertFlutterFontWeightToPdf(FontWeight? flutterFontWeight) {
    if (flutterFontWeight == null) return pw.FontWeight.normal;

    if (flutterFontWeight == FontWeight.bold ||
        flutterFontWeight.index >= FontWeight.w600.index) {
      return pw.FontWeight.bold;
    }

    return pw.FontWeight.normal;
  }

  /// Converter FontStyle do Flutter para PDF
  pw.FontStyle _convertFlutterFontStyleToPdf(FontStyle? flutterFontStyle) {
    if (flutterFontStyle == FontStyle.italic) {
      return pw.FontStyle.italic;
    }
    return pw.FontStyle.normal;
  }

  /// Converter TextDecoration do Flutter para PDF
  pw.TextDecoration _convertFlutterTextDecorationToPdf(
      TextDecoration? flutterDecoration) {
    if (flutterDecoration == TextDecoration.underline) {
      return pw.TextDecoration.underline;
    } else if (flutterDecoration == TextDecoration.lineThrough) {
      return pw.TextDecoration.lineThrough;
    }
    return pw.TextDecoration.none;
  }

  /// Criar span inline
  pw.InlineSpan _createInlineSpan(
      InlineElement element, double fontSize, pw.FontWeight fontWeight) {
    switch (element.type) {
      case InlineType.text:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize,
            fontWeight: fontWeight,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.bold:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize,
            fontWeight: pw.FontWeight.bold,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.italic:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontStyle: pw.FontStyle.italic,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.code:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize - 1,
            fontWeight: fontWeight,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.latex:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize - 1,
            fontWeight: fontWeight,
            fontStyle: pw.FontStyle.italic,
            color: pw.PdfColor.fromInt(0xFF888888),
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.span:
        final styleMap = element.style != null
            ? EnhancedMarkdownParser.parseStyle(element.style!)
            : <String, dynamic>{};

        // Converter cores do Flutter para PDF corretamente
        final textColor = styleMap['color'] != null
            ? _convertFlutterColorToPdfColor(styleMap['color'] as Color?)
            : pw.PdfColors.black;

        final pdfFontWeight = styleMap['fontWeight'] != null
            ? _convertFlutterFontWeightToPdf(
                styleMap['fontWeight'] as FontWeight?)
            : fontWeight;

        final fontStyle = styleMap['fontStyle'] != null
            ? _convertFlutterFontStyleToPdf(styleMap['fontStyle'] as FontStyle?)
            : pw.FontStyle.normal;

        final decoration = styleMap['decoration'] != null
            ? _convertFlutterTextDecorationToPdf(
                styleMap['decoration'] as TextDecoration?)
            : pw.TextDecoration.none;

        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize,
            fontWeight: pdfFontWeight,
            color: textColor,
            fontStyle: fontStyle,
            decoration: decoration,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.kbd:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize - 1,
            fontWeight: pw.FontWeight.bold,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.mark:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize,
            fontWeight: fontWeight,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.subscript:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize * 0.7,
            fontWeight: fontWeight,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );

      case InlineType.superscript:
        return pw.TextSpan(
          text: element.content,
          style: pw.TextStyle(
            fontSize: fontSize * 0.7,
            fontWeight: fontWeight,
            color: pw.PdfColors.black,
            font: _getDefaultFont(),
            fontFallback: _getFontFallbacks(),
          ),
        );
    }
  }

  /// Obter tamanho da fonte para tÃ­tulos
  double _getHeadingFontSize(int level) {
    switch (level) {
      case 1:
        return 28.0;
      case 2:
        return 24.0;
      case 3:
        return 20.0;
      case 4:
        return 18.0;
      case 5:
        return 16.0;
      case 6:
        return 14.0;
      default:
        return 14.0;
    }
  }

  /// Obter espaÃ§amento para tÃ­tulos
  double _getHeadingSpacing(int level) {
    switch (level) {
      case 1:
        return 20.0;
      case 2:
        return 18.0;
      case 3:
        return 16.0;
      case 4:
        return 14.0;
      case 5:
        return 12.0;
      case 6:
        return 10.0;
      default:
        return 10.0;
    }
  }

  /// Dividir conteÃºdo em pÃ¡ginas A4
  List<List<pw.Widget>> _splitContentIntoPages(
      List<pw.Widget> widgets, String title) {
    print('ğŸ“„ [PDF] Dividindo ${widgets.length} widgets em pÃ¡ginas...');
    final pages = <List<pw.Widget>>[];
    var currentPage = <pw.Widget>[];
    var currentHeight = 0.0;

    const maxPageHeight = 700.0;
    const firstPageMaxHeight = 600.0;

    bool isFirstPage = true;
    double pageLimit = firstPageMaxHeight;

    for (final widget in widgets) {
      final estimatedHeight = _estimateWidgetHeight(widget);

      if (currentHeight + estimatedHeight > pageLimit &&
          currentPage.isNotEmpty) {
        pages.add(List.from(currentPage));
        currentPage.clear();
        currentHeight = 0.0;
        isFirstPage = false;
        pageLimit = maxPageHeight;
      }

      currentPage.add(widget);
      currentHeight += estimatedHeight;
    }

    if (currentPage.isNotEmpty) {
      pages.add(currentPage);
    }

    if (pages.isEmpty) {
      pages.add([pw.Text('ConteÃºdo vazio')]);
    }

    print('ğŸ“„ [PDF] PÃ¡ginas criadas: ${pages.length} pÃ¡ginas');
    return pages;
  }

  /// Estimar altura de um widget PDF
  double _estimateWidgetHeight(pw.Widget widget) {
    if (widget is pw.Text) {
      return 20.0;
    } else if (widget is pw.RichText) {
      return 20.0;
    } else if (widget is pw.SizedBox) {
      return 10.0;
    } else if (widget is pw.Container) {
      return 60.0; // Blocos de cÃ³digo, blockquotes
    } else if (widget is pw.Row) {
      return 20.0; // Lista items
    } else if (widget is pw.Table) {
      return 40.0; // Tabelas
    }
    return 20.0;
  }

  /// Gerar PDF como bytes em memÃ³ria (para impressÃ£o)
  Future<Uint8List?> generatePdfBytes({
    required String markdown,
    required String title,
    String? author,
    String? subject,
  }) async {
    print('ğŸ–¨ï¸ [PDF] ===== INICIANDO GERAÃ‡ÃƒO DE PDF PARA IMPRESSÃƒO =====');
    print('ğŸ–¨ï¸ [PDF] TÃ­tulo: $title');
    print('ğŸ–¨ï¸ [PDF] Tamanho do markdown: ${markdown.length} caracteres');

    try {
      print('ğŸ–¨ï¸ [PDF] Carregando fontes...');
      await _loadFonts();
      print('âœ… [PDF] Fontes carregadas com sucesso');

      print('ğŸ–¨ï¸ [PDF] Criando documento PDF...');
      final pdf = pw.Document();
      print('âœ… [PDF] Documento PDF criado');

      print('ğŸ–¨ï¸ [PDF] Sanitizando markdown...');
      String sanitizedMarkdown = _sanitizeText(markdown);
      print(
          'ğŸ–¨ï¸ [PDF] Markdown sanitizado: ${sanitizedMarkdown.length} caracteres');

      print('ğŸ–¨ï¸ [PDF] Parsing markdown...');
      final blocks = EnhancedMarkdownParser.parseMarkdown(sanitizedMarkdown,
          enableHtmlEnhancements: true);
      print('ğŸ–¨ï¸ [PDF] Blocos parseados: ${blocks.length} blocos');

      print('ğŸ–¨ï¸ [PDF] Convertendo blocos para widgets PDF...');
      final contentWidgets = await _convertBlocksToPdfWidgets(blocks);
      print('ğŸ–¨ï¸ [PDF] Widgets convertidos: ${contentWidgets.length} widgets');

      print('ğŸ–¨ï¸ [PDF] Dividindo conteÃºdo em pÃ¡ginas...');
      final pages = _splitContentIntoPages(contentWidgets, title);
      print('ğŸ–¨ï¸ [PDF] PÃ¡ginas criadas: ${pages.length} pÃ¡ginas');

      print('ğŸ–¨ï¸ [PDF] Adicionando pÃ¡ginas ao PDF...');
      for (int i = 0; i < pages.length; i++) {
        print('ğŸ–¨ï¸ [PDF] Adicionando pÃ¡gina ${i + 1}/${pages.length}');
        pdf.addPage(
          pw.Page(
            pageFormat: PdfPageFormat.a4,
            margin: const pw.EdgeInsets.all(40),
            build: (pw.Context context) => pw.Column(
              children: [
                // CabeÃ§alho
                pw.Container(
                  margin: const pw.EdgeInsets.only(bottom: 20),
                  child: pw.Row(
                    mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                    children: [
                      pw.Text(
                        title,
                        style: pw.TextStyle(
                          fontSize: 18,
                          fontWeight: pw.FontWeight.bold,
                          font: _getDefaultFont(),
                          fontFallback: _getFontFallbacks(),
                        ),
                      ),
                      pw.Text(
                        '${DateTime.now().day}/${DateTime.now().month}/${DateTime.now().year}',
                        style: pw.TextStyle(
                          fontSize: 12,
                          color: pw.PdfColor.fromInt(0xFF888888),
                          font: _getDefaultFont(),
                          fontFallback: _getFontFallbacks(),
                        ),
                      ),
                    ],
                  ),
                ),

                // ConteÃºdo da pÃ¡gina
                pw.Expanded(
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: pages[i],
                  ),
                ),

                // RodapÃ©
                pw.SizedBox(height: 20),
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    pw.Text(
                      'Bloquinho - $title',
                      style: pw.TextStyle(
                          fontSize: 10, color: pw.PdfColor.fromInt(0xFF888888)),
                    ),
                    pw.Text(
                      'PÃ¡gina ${i + 1} de ${pages.length}',
                      style: pw.TextStyle(
                          fontSize: 10, color: pw.PdfColor.fromInt(0xFF888888)),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      }
      print('âœ… [PDF] Todas as pÃ¡ginas adicionadas ao PDF');

      print('ğŸ–¨ï¸ [PDF] Gerando bytes do PDF...');
      final pdfBytes = await pdf.save();
      print('âœ… [PDF] PDF gerado com sucesso: ${pdfBytes.length} bytes');

      return pdfBytes;
    } catch (e, stackTrace) {
      print('âŒ [PDF] Erro ao gerar PDF para impressÃ£o: $e');
      print('âŒ [PDF] Stack trace: $stackTrace');
      return null;
    }
  }

  /// Sanitizar texto para evitar problemas UTF-16
  String _sanitizeText(String text) {
    print('ğŸ§¹ [PDF] Sanitizando texto: ${text.length} caracteres');
    if (text.isEmpty) return text;

    try {
      // Verificar se a string Ã© vÃ¡lida UTF-16
      text.codeUnits;

      // Remover caracteres de controle problemÃ¡ticos
      String sanitized =
          text.replaceAll(RegExp(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]'), '');

      // Garantir que nÃ£o hÃ¡ caracteres nulos
      sanitized = sanitized.replaceAll('\x00', '');

      // Verificar novamente se Ã© vÃ¡lida
      sanitized.codeUnits;

      print('ğŸ§¹ [PDF] Texto sanitizado: ${sanitized.length} caracteres');
      return sanitized;
    } catch (e) {
      print('âŒ [PDF] Erro ao sanitizar texto: $e');
      // Se houver erro, retornar string vazia
      return '';
    }
  }

  /// Cria uma imagem de fÃ³rmula LaTeX
  Future<pw.Widget?> _createLatexImage(String latex) async {
    print('ğŸ”¢ [PDF] Renderizando LaTeX: $latex');

    // Limpar a fÃ³rmula LaTeX
    String cleanLatex = latex.trim();
    if (cleanLatex.startsWith('\$') && cleanLatex.endsWith('\$')) {
      cleanLatex = cleanLatex.substring(1, cleanLatex.length - 1);
    }

    // Usar API MathJax para renderizar LaTeX como SVG
    final response = await http.post(
      Uri.parse('https://mathjax-node.herokuapp.com/mml2svg'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode(
          {'math': cleanLatex, 'format': 'TeX', 'svg': true, 'width': 600}),
    );

    if (response.statusCode == 200) {
      final svgData = response.body;
      print('âœ… [PDF] LaTeX renderizado com sucesso');

      // Converter SVG para imagem PNG usando API
      final pngResponse = await http.post(
        Uri.parse('https://api.kroki.io/svg2png'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'svg': svgData, 'width': 600, 'height': 200}),
      );

      if (pngResponse.statusCode == 200) {
        final pngData = pngResponse.bodyBytes;
        return pw.Image(
          pw.MemoryImage(pngData),
          width: 600,
          height: 200,
          fit: pw.BoxFit.contain,
        );
      }
    }

    // Fallback: mostrar como texto
    print('âš ï¸ [PDF] Fallback para texto LaTeX');
    return pw.Text(
      'FÃ³rmula: $cleanLatex',
      style: pw.TextStyle(
        font: _getDefaultFont(),
        fontSize: 12,
        fontStyle: pw.FontStyle.italic,
      ),
    );
  }

  /// Cria uma imagem de diagrama Mermaid
  Future<pw.Widget?> _createMermaidImage(String mermaidCode) async {
    print('ğŸ“Š [PDF] Renderizando Mermaid: ${mermaidCode.substring(0, 50)}...');

    // Limpar o cÃ³digo Mermaid
    String cleanMermaid = mermaidCode.trim();

    // Usar API kroki.io para renderizar Mermaid
    final encodedDiagram = base64Encode(utf8.encode(cleanMermaid));
    final url = 'https://kroki.io/mermaid/png/$encodedDiagram';

    final response = await http.get(Uri.parse(url));

    if (response.statusCode == 200) {
      final pngData = response.bodyBytes;
      print('âœ… [PDF] Mermaid renderizado com sucesso');

      return pw.Image(
        pw.MemoryImage(pngData),
        width: 600,
        height: 400,
        fit: pw.BoxFit.contain,
      );
    }

    // Fallback: mostrar como cÃ³digo
    print('âš ï¸ [PDF] Fallback para cÃ³digo Mermaid');
    return pw.Container(
      padding: pw.EdgeInsets.all(8),
      decoration: pw.BoxDecoration(
        color: pw.PdfColor.fromInt(0xFF44475A),
        border: pw.Border.all(color: pw.PdfColor.fromInt(0xFF888888)),
      ),
      child: pw.Text(
        'Diagrama Mermaid:\n$cleanMermaid',
        style: pw.TextStyle(
          font: _getDefaultFont(),
          fontSize: 10,
        ),
      ),
    );
  }
}
